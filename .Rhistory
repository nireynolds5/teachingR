, data = MyData
, add = TRUE # this plots this graph on top of the existing one
, pch = 19
, col = alpha(threegroupcolors, 0.1)
, method = "jitter"
, jitter = 0.2
, vertical = TRUE
)
stripchart(avgsize ~ treatment
, data = MyData
, add = TRUE # this plots this graph on top of the existing one
, pch = 19
, col = alpha(threegroupcolors, 0.1)
, method = "jitter"
, jitter = 0.2
, vertical = TRUE
)
stripchart(avgsize ~ treatment
, data = MyData
, add = TRUE # this plots this graph on top of the existing one
, pch = 19
, col = alpha(threegroupcolors, 0.1)
, method = "jitter"
, jitter = 0.2
, vertical = TRUE
)
stripchart(avgsize ~ treatment
, data = MyData
, add = TRUE # this plots this graph on top of the existing one
, pch = 19
, col = alpha(threegroupcolors, 0.1)
, method = "jitter"
, jitter = 0.2
, vertical = TRUE
)
stripchart(avgsize ~ treatment
, data = MyData
, add = TRUE # this plots this graph on top of the existing one
, pch = 19
, col = alpha(threegroupcolors, 0.1)
, method = "jitter"
, jitter = 0.2
, vertical = TRUE
)
stripchart(avgsize ~ treatment
, data = MyData
, add = TRUE # this plots this graph on top of the existing one
, pch = 19
, col = alpha(threegroupcolors, 0.1)
, method = "jitter"
, jitter = 0.2
, vertical = TRUE
)
stripchart(avgsize ~ treatment
, data = MyData
, add = TRUE # this plots this graph on top of the existing one
, pch = 19
, col = alpha(threegroupcolors, 0.1)
, method = "jitter"
, jitter = 0.2
, vertical = TRUE
)
stripchart(avgsize ~ treatment
, data = MyData
, add = TRUE # this plots this graph on top of the existing one
, pch = 19
, col = alpha(threegroupcolors, 0.1)
, method = "jitter"
, jitter = 0.2
, vertical = TRUE
)
stripchart(avgsize ~ treatment
, data = MyData
, add = TRUE # this plots this graph on top of the existing one
, pch = 19
, col = alpha(threegroupcolors, 0.1)
, method = "jitter"
, jitter = 0.2
, vertical = TRUE
)
stripchart(avgsize ~ treatment
, data = MyData
, add = TRUE # this plots this graph on top of the existing one
, pch = 19
, col = alpha(threegroupcolors, 0.1)
, method = "jitter"
, jitter = 0.2
, vertical = TRUE
)
stripchart(avgsize ~ treatment
, data = MyData
, add = TRUE # this plots this graph on top of the existing one
, pch = 19
, col = alpha(threegroupcolors, 0.1)
, method = "jitter"
, jitter = 0.2
, vertical = TRUE
)
stripchart(avgsize ~ treatment
, data = MyData
, add = TRUE # this plots this graph on top of the existing one
, pch = 19
, col = alpha(threegroupcolors, 0.1)
, method = "jitter"
, jitter = 0.2
, vertical = TRUE
)
stripchart(avgsize ~ treatment
, data = MyData
, add = TRUE # this plots this graph on top of the existing one
, pch = 19
, col = alpha(threegroupcolors, 0.1)
, method = "jitter"
, jitter = 0.2
, vertical = TRUE
)
stripchart(avgsize ~ treatment
, data = MyData
, add = TRUE # this plots this graph on top of the existing one
, pch = 19
, col = alpha(threegroupcolors, 0.1)
, method = "jitter"
, jitter = 0.2
, vertical = TRUE
)
stripchart(avgsize ~ treatment
, data = MyData
, add = TRUE # this plots this graph on top of the existing one
, pch = 19
, col = alpha(threegroupcolors, 0.1)
, method = "jitter"
, jitter = 0.2
, vertical = TRUE
)
stripchart(avgsize ~ treatment
, data = MyData
, add = TRUE # this plots this graph on top of the existing one
, pch = 19
, col = alpha(threegroupcolors, 0.1)
, method = "jitter"
, jitter = 0.2
, vertical = TRUE
)
stripchart(avgsize ~ treatment
, data = MyData
, add = TRUE # this plots this graph on top of the existing one
, pch = 19
, col = alpha(threegroupcolors, 0.1)
, method = "jitter"
, jitter = 0.2
, vertical = TRUE
)
stripchart(avgsize ~ treatment
, data = MyData
, add = TRUE # this plots this graph on top of the existing one
, pch = 19
, col = alpha(threegroupcolors, 0.1)
, method = "jitter"
, jitter = 0.2
, vertical = TRUE
)
stripchart(avgsize ~ treatment
, data = MyData
, add = TRUE # this plots this graph on top of the existing one
, pch = 19
, col = alpha(threegroupcolors, 0.1)
, method = "jitter"
, jitter = 0.2
, vertical = TRUE
)
stripchart(avgsize ~ treatment
, data = MyData
, add = TRUE # this plots this graph on top of the existing one
, pch = 19
, col = alpha(threegroupcolors, 0.1)
, method = "jitter"
, jitter = 0.2
, vertical = TRUE
)
stripchart(avgsize ~ treatment
, data = MyData
, add = TRUE # this plots this graph on top of the existing one
, pch = 19
, col = alpha(threegroupcolors, 0.1)
, method = "jitter"
, jitter = 0.2
, vertical = TRUE
)
text(x=c(1:nbGroup)
, y=N_y_offset*y_max
, cex = 1
, col = threegroupcolors
, "haha" #paste(Nice_Plot$n,sep="")  # again, the sample size 'n' is directly extracted from the plot
)
Nice_Plot <- boxplot(avgsize ~ treatment
, data = MyData
, xlab = "X Concept [unit measured]"
, ylab = "Y Concept [unit measured]"
, range = 0
# Always make axis descriptions as clear and comprehensive as possible
, names = c("Large bees", "Middling bees", "Small bees")
, col = alpha(threegroupcolors, 0.5) # use same colors as elsewhere,
# but slightly transparent so we can see data points
, ylim = c(y_min, y_max) # always think about the scale - starting from zero is typically better
)
# Putting sample sizes above bars
nbGroup <- nlevels(as.factor(Nice_Plot$names)) # this is just a way to extract
# category names from the plot - you could get this directly from data
text(x=c(1:nbGroup)
, y=N_y_offset*y_max
, cex = 1
, col = threegroupcolors
, paste("N=", Nice_Plot$n, sep="")  # again, the sample size 'n' is directly extracted from the plot
)
mtext("additional margin label", side=2, line=2)
mtext("additional margin label", side=2, line=2, las=0)
# Saving the plot into a variable allows us to access plot parameters afterwards.
Nice_Plot <- boxplot(avgsize ~ treatment
, data = MyData
, xlab = "X Concept [unit measured]"
, ylab = "Y Concept [unit measured]"
, range = 0
# Always make axis descriptions as clear and comprehensive as possible
, names = c("Large bees", "Middling bees", "Small bees")
, col = alpha(threegroupcolors, 0.5) # use same colors as elsewhere,
# but slightly transparent so we can see data points
, ylim = c(y_min, y_max) # always think about the scale - starting from zero is typically better
)
# Putting sample sizes above bars
nbGroup <- nlevels(as.factor(Nice_Plot$names)) # this is just a way to extract
# category names from the plot - you could get this directly from data
text(x=c(1:nbGroup)
, y=N_y_offset*y_max
, cex = 1
, col = threegroupcolors
, paste("N=", Nice_Plot$n, sep="")  # again, the sample size 'n' is directly extracted from the plot
)
mtext("additional margin label", side=2, line=2, las=0)
mtext("additional margin label on outside", side=1, line=5, las=0, xpd = TRUE)
# Margins:
par(oma = c(2,2,2,2), mar = c(5,5,1,1), mgp=c(3, 1, 0), las=1)
# bottom, left, top, right
par(mfrow=c(1,1))
# How to make a great boxplot -
# Saving the plot into a variable allows us to access plot parameters afterwards.
Nice_Plot <- boxplot(avgsize ~ treatment
, data = MyData
, xlab = "X Concept [unit measured]"
, ylab = "Y Concept [unit measured]"
, range = 0
# Always make axis descriptions as clear and comprehensive as possible
, names = c("Large bees", "Middling bees", "Small bees")
, col = alpha(threegroupcolors, 0.5) # use same colors as elsewhere,
# but slightly transparent so we can see data points
, ylim = c(y_min, y_max) # always think about the scale - starting from zero is typically better
)
# Putting sample sizes above bars
nbGroup <- nlevels(as.factor(Nice_Plot$names)) # this is just a way to extract
# category names from the plot - you could get this directly from data
text(x=c(1:nbGroup)
, y=N_y_offset*y_max
, cex = 1
, col = threegroupcolors
, paste("N=", Nice_Plot$n, sep="")  # again, the sample size 'n' is directly extracted from the plot
)
mtext("additional margin label", side=2, line=2, las=0)
mtext("additional margin label on outside", side=1, line=5, las=0, xpd = TRUE)
par(oma = c(2,2,2,2), mar = c(4,4,1,1), mgp=c(3, 1, 0), las=1)
# bottom, left, top, right
par(mfrow=c(1,1))
# How to make a great boxplot -
# Saving the plot into a variable allows us to access plot parameters afterwards.
Nice_Plot <- boxplot(avgsize ~ treatment
, data = MyData
, xlab = "X Concept [unit measured]"
, ylab = "Y Concept [unit measured]"
, range = 0
# Always make axis descriptions as clear and comprehensive as possible
, names = c("Large bees", "Middling bees", "Small bees")
, col = alpha(threegroupcolors, 0.5) # use same colors as elsewhere,
# but slightly transparent so we can see data points
, ylim = c(y_min, y_max) # always think about the scale - starting from zero is typically better
)
# Putting sample sizes above bars
nbGroup <- nlevels(as.factor(Nice_Plot$names)) # this is just a way to extract
# category names from the plot - you could get this directly from data
text(x=c(1:nbGroup)
, y=N_y_offset*y_max
, cex = 1
, col = threegroupcolors
, paste("N=", Nice_Plot$n, sep="")  # again, the sample size 'n' is directly extracted from the plot
)
mtext("additional margin label", side=2, line=2, las=0)
mtext("additional margin label on outside", side=1, line=5, las=0, xpd = TRUE)
stripchart(avgsize ~ treatment
, data = MyData
, add = TRUE # this plots this graph on top of the existing one
, pch = 19
, col = threegroupcolors
, method = "jitter"
, jitter = 0.2
, vertical = TRUE
)
install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
# From 2019 book:
install.packages(c("coda","mvtnorm","devtools"))
library(devtools)
devtools::install_github("rmcelreath/rethinking",ref="Experimental")
devtools::install_github("rmcelreath/rethinking",ref="Experimental")
devtools::install_github("rmcelreath/rethinking", force=TRUE)
# From R Documentation:
devtools::install_github("stan-dev/cmdstanr")
install.packages(c("coda","mvtnorm","devtools","loo","dagitty"))
d
devtools::install_github("rmcelreath/rethinking")
library(rethinking)
library(scales)
library(rstan)
# From 2019 book:
#install.packages(c("coda","mvtnorm","devtools"))
library(devtools)
### WHAT IS BAYES? Calculating a posterior probability -----------
# Calculating the likelihood of the data
# if prob is the probability of the outcome 'success'
# on each sample
no_of_samples <- 9
no_of_successes <- 6
# Here this is the probability density for a binomial function
# which is what you need when drawing with replacement
dbinom(no_of_successes, size=no_of_samples , prob=0.5 )
?dbinom
# Here this is the probability density for a binomial function
# which is what you need when drawing with replacement
binomal<-dbinom(no_of_successes, size=no_of_samples , prob=0.5 ) #out put is 0.1640625
library(rstan)
# From 2019 book:
#install.packages(c("coda","mvtnorm","devtools"))
library(devtools)
library(rethinking)
library(scales)
### WHAT IS BAYES? Calculating a posterior probability -----------
# Calculating the likelihood of the data
# if prob is the probability of the outcome 'success'
# on each sample
no_of_samples <- 9
no_of_successes <- 6
# Here this is the probability density for a binomial function
# which is what you need when drawing with replacement
binomal<-dbinom(no_of_successes, size=no_of_samples , prob=0.5 ) #out put is 0.1640625, the probabilities of getting 6/9 flip coin
#### (1) Simple Grid approximation: -------------
grid_approx <- function(W, L, grid_size=10) {
# define grid of possible hypotheses/values of thing to be estimated
p_grid <- seq(from=0 , to=1 , length.out=grid_size)
# define prior across all hypotheses
prior <- rep(1 , grid_size)
# Alternative priors:
#prior <- ifelse( p_grid < 0.5 , 0 , 1 )
#prior <- exp( -5*abs( p_grid - 0.5 ) )
# Standardizing just for the sake of the graph
prior <- prior/sum(prior)
# compute likelihood at each value in grid (i.e. data given each hypothesis)
# Note that here we have a clear mathematical function to do this; usually we don't
likelihood <- dbinom(W, size=W+L, prob=p_grid )
# compute product of likelihood and prior
unstd.posterior <- likelihood * prior
# standardize the posterior, so it sums to 1
posterior <- unstd.posterior / sum(unstd.posterior)
# Note that there is a bit of a sleight of hand here in that before he called the ratio
# not just the numerator the 'likelihood'. Don't worry about it if you didn't notice.
# Plot all three
plot(p_grid , posterior
, xlab="Proportion of water on globe"
, ylab="Posterior probability"
, ylim=c(0,1)
, col = "black"
, pch = 19
, yaxt='n'
#, type="b"
)
points(p_grid, prior, type="b" , col = "blue")
points(p_grid, likelihood, type="b" , col = "red")
return(posterior)
}
#### (1) Simple Grid approximation: -------------
grid_approx <- function(W, L, grid_size=10) {
# define grid of possible hypotheses/values of thing to be estimated
p_grid <- seq(from=0 , to=1 , length.out=grid_size)
# define prior across all hypotheses
prior <- rep(1 , grid_size)
# Alternative priors:
#prior <- ifelse( p_grid < 0.5 , 0 , 1 )
#prior <- exp( -5*abs( p_grid - 0.5 ) )
# Standardizing just for the sake of the graph
prior <- prior/sum(prior)
# compute likelihood at each value in grid (i.e. data given each hypothesis)
# Note that here we have a clear mathematical function to do this; usually we don't
likelihood <- dbinom(W, size=W+L, prob=p_grid )
# compute product of likelihood and prior
unstd.posterior <- likelihood * prior
# standardize the posterior, so it sums to 1
posterior <- unstd.posterior / sum(unstd.posterior)
# Note that there is a bit of a sleight of hand here in that before he called the ratio
# not just the numerator the 'likelihood'. Don't worry about it if you didn't notice.
# Plot all three
plot(p_grid , posterior
, xlab="Proportion of water on globe"
, ylab="Posterior probability"
, ylim=c(0,1)
, col = "black"
, pch = 19
, yaxt='n'
#, type="b"
)
points(p_grid, prior, type="b" , col = "blue")
points(p_grid, likelihood, type="b" , col = "red")
return(posterior)
}
# Let's try it:
grid_approx(5, 3)
# Let's try it:
grid_approx(5, 3, 15)
#### (1) Simple Grid approximation: -------------
grid_approx <- function(W, L, grid_size=10) { #W is water, L is land, grid_size is the grid, can change in fomrat
# define grid of possible hypotheses/values of thing to be estimated
p_grid <- seq(from=0 , to=1 , length.out=grid_size)
# define prior across all hypotheses
#prior <- rep(1 , grid_size)
# Alternative priors:
prior <- ifelse( p_grid < 0.5 , 0 , 1 )
#prior <- exp( -5*abs( p_grid - 0.5 ) )
# Standardizing just for the sake of the graph
prior <- prior/sum(prior)
# compute likelihood at each value in grid (i.e. data given each hypothesis)
# Note that here we have a clear mathematical function to do this; usually we don't
likelihood <- dbinom(W, size=W+L, prob=p_grid )
# compute product of likelihood and prior
unstd.posterior <- likelihood * prior
# standardize the posterior, so it sums to 1
posterior <- unstd.posterior / sum(unstd.posterior)
# Note that there is a bit of a sleight of hand here in that before he called the ratio
# not just the numerator the 'likelihood'. Don't worry about it if you didn't notice.
# Plot all three
plot(p_grid , posterior
, xlab="Proportion of water on globe"
, ylab="Posterior probability"
, ylim=c(0,1)
, col = "black"
, pch = 19
, yaxt='n'
#, type="b"
)
points(p_grid, prior, type="b" , col = "blue")
points(p_grid, likelihood, type="b" , col = "red")
return(posterior)
}
# Let's try it:
grid_approx(5, 3)
#### (2) Quadratic approximation using quap(): -----------------
globe.qa <- function(W, L) {
summary_quadratic_approx <-
# precis() is his 'summarize model results' function
precis(
# quap() is his actual model fitting function, which takes a list of model
# assumptions and the data as its two arguments.
quap(
alist(
W ~ dbinom(W+L ,p) , # binomial likelihood
p ~ dunif(0,1) # uniform prior
),
data=list(W=W,L=L)
)
)
# display the summary of quadratic approximation
summary_quadratic_approx
# Then add curves/lines to the presumed existing graph of prior and likelihood.
# precis() returns the mean, sd, 5.5% and 94.5% percentile of the posterior.
# So we can plot the mean of the posterior as a vertical line:
abline(v=summary_quadratic_approx[1,1], col= alpha("seagreen", 0.5), lwd = 4)
# And/or we can plot the interval from the lower to the higher percentile:
segments(summary_quadratic_approx[1,3]
,0.5
,summary_quadratic_approx[1,4]
,col="seagreen1"
,lwd = 3
)
# And/or we can plot just the interval from mean-sd to mean+sd:
segments(summary_quadratic_approx[1,1]-summary_quadratic_approx[1,2]
,0.5
,summary_quadratic_approx[1,1]+summary_quadratic_approx[1,2]
,col="seagreen3"
,lwd = 6
)
# Or, we plot an estimate of the entire posterior distribution by fitting
# a Gaussian function with the same mean and standard deviation:
curve((dnorm(x
, summary_quadratic_approx[1,1]
, summary_quadratic_approx[1,2])
)/max(dnorm(x, summary_quadratic_approx[1,1]
, summary_quadratic_approx[1,2])
)
, add=TRUE
, col="black"
, lwd = 2)
# Analytical calculation from book - note that the entire
# point of the approximations above is that this cannot usually be done
# for real problems
curve( (dbeta( x , W+1 , L+1 ))/max(dbeta( x , W+1 , L+1 )) , from=0 , to=1 , add=TRUE, lty=2, col = "purple")
# Note that for both 'curves' I normalized by their maximum, so y-values
# do not correspond to actual pdf but the peak is standardized at y=1
}
# Let's try it:
globe.qa(5, 3)
